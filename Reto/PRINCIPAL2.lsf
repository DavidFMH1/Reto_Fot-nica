# ============================================
# BARRIDO VarFDE - SOLO ALMACENAR DATOS
# - Selección: modo TE-like con menor Aeff
# - Salida: datos_modos.tsv (tabla numérica)
# ============================================

clear;
switchtolayout;

# ---------- Parámetros ----------
Alt_SiO2=1;  Anc_SiO2=7;
Alt_Si=Alt_SiO2;  Anc_Si=Anc_SiO2;

resol_x_FDE=50; resol_y_FDE=50; sale_FDE=1;

Alt_ini=0.4; Alt_fin=1.0; num_puntos_Alt=1;
Anc_ini=0.5; Anc_fin=2.0; num_puntos_Anc=1;
lamb_ini=0.72; lamb_fin=0.89; num_puntos_lamb=1;   # µm

Alt_Si3N4 = linspace(Alt_ini,Alt_fin,num_puntos_Alt);
Anc_Si3N4 = linspace(Anc_ini,Anc_fin,num_puntos_Anc);
lamb_um   = linspace(lamb_ini,lamb_fin,num_puntos_lamb);
lamb_m    = lamb_um*1e-6;

# Búsqueda de modos
near_n=0; n_near=1.52; min_n=1.4; max_n=2.2;
if (near_n==1) {
  setanalysis("search","near n");
  setanalysis("n",n_near);
  setanalysis("use max index",0);
} else {
  setanalysis("search","in range");
  setanalysis("n1",max_n);   # superior
  setanalysis("n2",min_n);   # inferior
}
setanalysis("number of trial modes", 30);

# ---------- Criterios de selección ----------
te_frac_min = 0.80;    # fracción TE mínima (0..1)
prefer_te   = 1;       # 1 = exige TE-like

# ---------- Tabla larga en columnas ----------
# Columnas: Alt_um, Anc_um, lambda_um, neff, beta_per_m, Aeff_um2, TE_fraction, mode_idx
Nrows = num_puntos_Alt*num_puntos_Anc*num_puntos_lamb;
DATA  = zeros(Nrows, 8);   # matriz numérica
row   = 1;

# ---------- Barrido ----------
for (kk=1:num_puntos_Alt) {
  Alt_core = Alt_Si3N4(kk);   # µm
  for (ii=1:num_puntos_Anc) {
    Anc_core = Anc_Si3N4(ii); # µm

    Geometria;
    Mallas;

    for (nn=1:num_puntos_lamb) {
      wl_m = lamb_m(nn);
      setanalysis("wavelength", wl_m);

      nmodes = findmodes;

      # --- Selección: TE-like con menor Aeff ---
      best_idx = -1;
      best_aeff = 1e99;
      best_tef = -1;

      for (mm=1:nmodes) {
        mname = "mode"+num2str(mm);

        # Fracción TE: usa métrica nativa si existe; si no, calcula por campos
        tef = -1;
        if (havedata(mname,"TE polarization fraction")) {
          tef = real(getdata(mname,"TE polarization fraction"));  # 0..1
        } 
        if (prefer_te==1 && tef < te_frac_min) { continue; }

        # Área efectiva: nativa si existe; si no, por definición
        aeff = 0;
        if (havedata(mname,"Aeff")) {
          aeff = real(getdata(mname,"Aeff"));   # m^2
        } else {
          if (!exists("Ex")) { Ex = getdata(mname,"Ex"); Ey = getdata(mname,"Ey"); Ez = getdata(mname,"Ez");
                               x = getdata(mname,"x");   y  = getdata(mname,"y"); }
          dx = (x(length(x))-x(1))/max(1,(length(x)-1));
          dy = (y(length(y))-y(1))/max(1,(length(y)-1));
          dA = dx*dy;
          E2 = abs(Ex)^2 + abs(Ey)^2 + abs(Ez)^2;
          I1 = sum(sum(E2))*dA;
          I2 = sum(sum(E2^2))*dA;
          aeff = (I1^2)/max(I2,1e-300);        # m^2
        }

        if (aeff < best_aeff) { best_aeff=aeff; best_idx=mm; best_tef=tef; }
      } # mm

      # Si ninguno pasó el umbral TE, toma el de menor Aeff sin filtrar
      if (best_idx < 0) {
        for (mm=1:nmodes) {
          mname="mode"+num2str(mm);
          if (havedata(mname,"Aeff")) {
            aeff = real(getdata(mname,"Aeff"));
          } else {
            Ex = getdata(mname,"Ex"); Ey = getdata(mname,"Ey"); Ez = getdata(mname,"Ez");
            x  = getdata(mname,"x");  y  = getdata(mname,"y");
            dx = (x(length(x))-x(1))/max(1,(length(x)-1));
            dy = (y(length(y))-y(1))/max(1,(length(y)-1));
            dA = dx*dy;
            E2 = abs(Ex)^2 + abs(Ey)^2 + abs(Ez)^2;
            I1 = sum(sum(E2))*dA;
            I2 = sum(sum(E2^2))*dA;
            aeff = (I1^2)/max(I2,1e-300);
          }
          if (aeff < best_aeff) { best_aeff=aeff; best_idx=mm; best_tef=-1; }
        }
      }

      # --- Datos del modo elegido ---
      msel = "mode"+num2str(best_idx);
      selectmode(msel);
      neff_val = real(getdata(msel,"neff"));
      beta_val = 2*pi/wl_m * neff_val;       # 1/m
      aeff_um2 = best_aeff*1e12;             # m^2 -> µm^2

      # --- Rellena la fila de la tabla ---
      DATA(row,1) = Alt_core;        # Alt_um
      DATA(row,2) = Anc_core;        # Anc_um
      DATA(row,3) = lamb_um(nn);     # lambda_um
      DATA(row,4) = neff_val;        # neff
      DATA(row,5) = beta_val;        # beta_per_m
      DATA(row,6) = aeff_um2;        # Aeff_um2
      DATA(row,7) = best_tef;        # TE_fraction (0..1 o -1 si no se calculó)
      DATA(row,8) = best_idx;        # mode_idx
      row = row + 1;

    } # nn
  } # ii
} # kk

# ---------- Escribe el archivo una sola vez ----------
# (sin encabezado para evitar concatenar cadenas)
out_tsv = "datos_modos.tsv";
write(out_tsv, num2str(DATA));

?("Listo. Guardé "+out_tsv+" con "+num2str(Nrows)+" filas.");